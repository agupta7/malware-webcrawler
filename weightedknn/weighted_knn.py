import math
import numpy as np

class WeightedKnn:

    def __init__(self, dataset, k, b, featureMask):
        self.dataset = dataset
        self.k = k
        self.b = b
        self.featureMask = featureMask

    def predict(self, featureVector):
        k = self.k
        b = self.b
        featureMask = self.featureMask
        neighborhood = WeightedKnn.getKNeighbors(featureVector, self.dataset, k, featureMask)
        outsum = 0
        weightsum = 0
        for neighbor in neighborhood:
            try:
                outsum += (neighbor['distance'] ** -b) * neighbor['output']
                weightsum += neighbor['distance'] ** -b
            except ZeroDivisionError as e:
                return neighbor['output']

        return outsum / weightsum

    @classmethod
    def getDistance(cls, featureVectorA, featureVectorB):
        separation = (featureVectorB - featureVectorA) ** 2

        return math.sqrt(sum(separation))

    @classmethod
    def getKNeighbors(cls, featureVector, vectorList, k, featureMask = None):
        if featureMask is None:
            featureMask = np.ones(len(featureVector))
        for vector in vectorList:
            vector['distance'] = WeightedKnn.getDistance(featureMask * featureVector, featureMask * vector['featureVector'])
        return sorted(vectorList, key=lambda comparator: comparator['distance'] or 0)[:k]


