import math
import numpy as np

def normalizeToUnitVector(vector, featureMask=None):
    if featureMask is None:
        featureMask = np.ones(len(vector))
    radius = math.sqrt(sum((vector * np.array(featureMask)) ** 2)) 
    if radius != 0:
        vector = np.array(vector) / radius
    return vector

class WeightedKnn:

    def __init__(self, dataset, k, b, featureMask = None):
        self.dataset = dataset
        self.k = k
        self.b = b
        self.featureMask = featureMask
        
        for instance in dataset:
            instance['featureVector'] = normalizeToUnitVector(instance['featureVector'], featureMask)

    def predict(self, featureVector):
        k = self.k
        b = self.b
        featureMask = self.featureMask
        neighborhood = WeightedKnn.getKNeighbors(normalizeToUnitVector(featureVector), self.dataset, k, featureMask)
        outsum = 0
        weightsum = 0
        for neighbor in neighborhood:
            try:
                outsum += (neighbor['distance'] ** -b) * neighbor['output']
                weightsum += neighbor['distance'] ** -b
            except ZeroDivisionError as e:
                return neighbor['output']

        return outsum / weightsum

    @classmethod
    def getDistance(cls, featureVectorA, featureVectorB):
        separation = (featureVectorB - featureVectorA) ** 2

        return math.sqrt(sum(separation))

    @classmethod
    def getKNeighbors(cls, featureVector, vectorList, k, featureMask = None):
        if featureMask is None:
            featureMask = np.ones(len(featureVector))
        for vector in vectorList:
            vector['distance'] = WeightedKnn.getDistance(featureMask * featureVector, featureMask * vector['featureVector'])
        return sorted(vectorList, key=lambda comparator: comparator['distance'] or 0)[:k]


