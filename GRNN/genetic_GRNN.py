import numpy as np 
import random
import GRNN
import general

# function that performs arithmetic crossover
def _Arithmetic_CrossOver (parent1 , parent2, alpha):
	child1 = alpha*parent1 + (1-alpha)*parent2
	child2 = alpha*parent2 + (1-alpha)*parent1

	return child1,child2

# my fitness function basic on error of classification 
def Fitness (out):
	return 100-out		

# evaluate every element in the current population	
def Evaluate_poputation (X,Y, suggested_sigmas):
	print "start evaluating\n"
	fitness_dict = dict()
	for indx, inst in enumerate (suggested_sigmas):
		accuracy = GRNN.Main(X,Y,inst) # change the way you get your accuracy result  
		fitness_dict[inst] = Fitness(accuracy)
	
	return fitness_dict

# function that select parents from population z
def Select_parent (fitness_dict, population_size):
	print "start parents selections\n"
	# sort  dict by value, return best (min fitness) given size of parent indices
	cnt = 0 
	parents = [] # list of indices
	Acclist = []
	for key, value in sorted(fitness_dict.iteritems(),key=lambda (k,v):(v,k)):
		parents.append(key)	; cnt += 1 ; 
		Acclist.append (value)
		print "fit at sigma %f , and accu %f"%(key,1-value)
		if cnt == population_size:
			break
	return parents,Acclist

def Guassian_mutation (x,sigma):
	#Gaussian mutation of mean = 0 , and std = 1 
	R = np.random.standard_normal(1)
	return x + sigma*R
	
def Uiform_CrossOver (parent1, parent2,bais):
	# generate random value with values = 0 or 1 only (flip a coin )	
	ch1 = random.sample (set([0,1]),1) 
	ch2 = random.sample (set([0,1]),1)

	# if flip is 1 include parent1's value else parent2's
	child1 = ch1[0]*parent1 + (1-ch1[0])*parent2 # if flip is 1 include parent1's value else parent2's
	child2 = ch2[0]*parent1 + (1-ch2[0])*parent2

	return child1,child2
def Create_generation (parents, population):
	print "create new generation\n"
	childs = []
	for indx in range (population):
		chosen_parents = random.sample (parents,2)# randomly choose 2 parents 
		child1,child2 = Uiform_CrossOver (chosen_parents[0], chosen_parents[1],0.40)
		child1 = Guassian_mutation (child1, 0.1546 )
		child2 = Guassian_mutation (child2, 0.1546 )
		childs.append (child1)
		childs.append (child2)
	childs = np.array(childs) .reshape (len(childs),1)
	print "childs,", np.shape(childs)
	return childs 	
def Genatic_Algo (X,Y, parents, poputation, maxiter):
	print "GENATIC ALGO: \n"
	for iter in range (maxiter):
		fitness = Evaluate_poputation(X,Y,parents)
		parents,Acclist = Select_parent (fitness, poputation)
		print Acclist
		childs = Create_generation (parents,poputation)
	#	print "SHAPES: ", np.shape (childs)
		print "len ",len (parents)
		parents = np.array(parents).reshape ( len(parents),1)
	#	print "SHAPES: ", np.shape (parents)  
		parents = np.concatenate ( (parents,childs) )
		parents = np.array(parents).reshape(len(parents))
def Main ():
	X, Y = general.Load_Data ("malware_dataset.csv")
        X,Y = general.shuffle_in_unison_scary (X,Y)
        X = general.Normalization_min_max (X)
	initial_sigmas = []
	initial_sigmas.append (0.224301902592)
	initial_sigmas.append (0.25798202427)
	for i in range (15):
		initial_sigmas.append (random.uniform (0.01,1.5) )
		
	Genatic_Algo (X,Y, initial_sigmas,6,10)


Main()
