import math
import numpy as np
import cPickle 
import random
import general
import GRNN
import operator 
import sys 

# my fitness function based on classification error  
def Fitness (out): # done 
	fitness = abs(out)
	return fitness	

# flat cross over 
def Flat_Cross_Over (parent1,parent2): # done 
	child = [] 
	for indx in range (len(parent1)):
		child.append (random.uniform(parent1[indx], parent2[indx]) )

	return child 
		
# Evaluate population 
def Evaluate_poputation (GRNN_inst, parents): # done 
	fitness_dict = dict()
	output = np.zeros(len(parents))
	for index, parent in enumerate(parents):
		output[index] = GRNN_inst.predict(parent)

	for indx in range (len (parents)):
	        fitness_dict.update( {indx:Fitness(output[indx])} )  # list of tuples of all indices, fitness
	
        return fitness_dict, output

def Tournament_selection (parents, fitness): # done 
	chosen = random.sample ( range( len(parents)),2)# randomly choose 2 parents
	if fitness[ chosen[0] ] <=  fitness[ chosen[1] ]: # choose the best
		winner1 = chosen[0]
	else:	winner1 = chosen[1]

	while (chosen[0] == winner1 or chosen[1] == winner1): # make sure winner1 is not selected again 
		chosen = random.sample (range(len (parents)),2)# randomly choose 2 parents

	if fitness[ chosen[0] ] <=  fitness[ chosen[1] ]: # choose the best
		winner2 = chosen[0]
	else:	winner2 = chosen[1]

	return [ parents[winner1], parents[winner2] ]
	
def Create_child ( parents,fitness): # done 
#        print "create child\n"
	chosen_parents = Tournament_selection(parents, fitness)
        child = Flat_Cross_Over (chosen_parents[0], chosen_parents[1])#crossover

        return child

def replace_worst_parent(parents,child,fitness_p,fitness_c):# done 
	worst_k = -1 ; worst_v= -1  # search for worst parent	
	for key, value in fitness_p.iteritems():
		if value > worst_v:
			worst_v = value ; worst_k = key ; 

        if worst_v > fitness_c[0]:
            parents [worst_k] = child ; 
            fitness_p[worst_k] = fitness_c [0]

	return parents, fitness_p

def Genatic_Algo (GRNN_inst, parents, poputation, maxiter): # done 
        predictions = []
        fitness_p, pred = Evaluate_poputation(GRNN_inst,parents) # evaluate first population
        predictions.extend(pred)
        iter = 0
	while iter < maxiter:
		child = Create_child (parents, fitness_p) # create new generation 
       		fitness_c, pred = Evaluate_poputation(GRNN_inst,[child]) # evaluate current child
                if not math.isnan(fitness_c[0]):
                    parents, fitness_p = replace_worst_parent (parents,child,fitness_p,fitness_c)# replace worst parent
                    iter += 1
                    predictions.extend(pred)
		
	return parents ,fitness_p, predictions 
		
def Generate_initial_pop (pop_size, VF_size): # done 
	initial_population = [] 
	for indx in range (pop_size):
		initial_population.append(list(np.random.rand(VF_size)) )

	return initial_population

def Select_random_Pop (X, pop_size):
	X = list(X)
	initial_population = []
	for i in range (pop_size):
		R = random.sample( range(len(X)) , 1)
		initial_population.append(list( X[R[0]]))

	return initial_population
def evolve(datasetFile):
    sigma = 0.246711580707
    pop_size = 20 ; FV_size = 95 ; maxiter = 180; 
    GRNN_inst=  GRNN.GRNNPredictor(datasetFile, sigma) 

    initial_pop = Generate_initial_pop (pop_size, FV_size)
    candidates , fitness, predictions = Genatic_Algo (GRNN_inst,initial_pop,pop_size,maxiter)
    print fitness
    return candidates, predictions

    
def Main ():
	sigma = 0.246711580707
	pop_size = 20 ; FV_size = 95 ; maxiter = 180; 
	GRNN_inst=  GRNN.GRNNPredictor("malware_dataset.csv", sigma) 

	initial_pop = Generate_initial_pop (pop_size, FV_size)
#	initial_pop = Select_random_Pop (GRNN_inst.X,pop_size)
	candidates , fitness, predictions = Genatic_Algo (GRNN_inst,initial_pop,pop_size,maxiter)
        print predictions

	for key, value in fitness.iteritems():
		print key,": ",value
	print	
	
	
	import cPickle
	with open ("genetic_algo_pop","wb")as file:
		cPickle.dump (candidates,file)
if __name__ == "__main__":
    Main()
