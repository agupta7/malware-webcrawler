import numpy as np 
import cPickle 
import random
import general
import GRNN
import operator 

# my fitness function based on classification error  
def Fitness (out):
	fitness = abs(out)
	return fitness	

# flat cross over 
def Flat_Cross_Over (parent1,parent2):
	child = [] 
	for indx in range (len(parent1)):
		child.append (random.uniform(parent1[indx], parent2[indx]) )

	return child 
		
# Evaluate population 
def Evaluate_poputation (X,Y,sigma, parents):
#        print "start evaluating\n"
        fitness_dict = []
	
        output = GRNN.Predict(X,Y,sigma,parents) 

	for indx in range (len (parents)):
	        fitness_dict.append ( (indx,Fitness(output[indx]) ) ) # list of tuples of all indices, fitness

        return fitness_dict

# function that select parents from population z
def Select_parent (prev_parents, fitness_dict, population_size):
        print "start parents selections\n"
# sort  dict by value, return best (min fitness) given size of parent indices
        fitness_dict.sort(key=operator.itemgetter(1)) # sort tuples list by fitness, key = indx, value= fitness

        cnt = 0
        parents = [] # list of indices
        updated_fitness = []

        for key, value in fitness_dict:
                parents.append(prev_parents[key])
                updated_fitness.append( (cnt,value) )
                cnt += 1
                if cnt == population_size:
                        break
        return parents,updated_fitness


def Tournament_selection (X,Y, sigma, parents):
	chosen1 = random.sample (parents,2)# randomly choose 2 parents 
	chosen2 = random.sample (parents,2)# randomly choose 2 parents
	both= chosen1 + chosen2 
	output = Evaluate_poputation (X,Y,sigma,both)	# evaluate all 

	fitness = dict () 	
	for key,value in output:
		fitness[key] =  Fitness(value)

	if fitness[0] <= fitness[1]:	winner1 = 0  # choose the best of set1 
	else:	winner1 = 1

	if fitness[2] <= fitness[3]:	winner2 = 2 # choose the best of set2 
	else:	winner2 = 3

	chosen_parents = [] 
	chosen_parents.append ( both[winner1])
	chosen_parents.append ( both[winner2])
	return chosen_parents
	
def Create_generation (X,Y,sigma, parents, population):
        print "create new generation\n"
        childs = []
        for indx in range (population):
		chosen_parents = Tournament_selection (X,Y,sigma, parents)
                child = Flat_Cross_Over (chosen_parents[0], chosen_parents[1])#crossover
                childs.append (child)

        return childs

def Merge_Lists (parents, childs ,fitness_p, fitness_c):
        # increment all indices of child's fitness, bcz it'll be appended to parents 
        fitness_c = [ (key+len(parents), value) for key,value in fitness_c]
        # now concatenate, without losing duplicate indices from both fitnesses
        parents = np.concatenate ( (parents,childs) )
        fitness_p = fitness_p + fitness_c

        return parents , fitness_p

def Genatic_Algo (X,Y,sigma, parents, poputation, maxiter):

        fitness_p = Evaluate_poputation(X,Y,sigma,parents) # evaluate first population
        parents,fitness_p = Select_parent (parents,fitness_p, poputation)# select best n 

	candidates = [] 
        for iter in range (0,maxiter):
                print "ITER: %d"%iter, " ----------------------------"
                childs = Create_generation (X,Y,sigma, parents,poputation) # create new generation 
                fitness_c = Evaluate_poputation(X,Y,sigma,childs) # evaluate current population

                parents, fitness_p= Merge_Lists (parents,childs, fitness_p,fitness_c)#concatenate parents &  childs
                parents,fitness_p = Select_parent (parents,fitness_p, poputation)# select best n
		
		out = GRNN.Predict(X,Y,sigma,parents) 
		print "out for feature vectors of iter %d:\n"%iter, out
                print"\n-------------------------------"
		candidates.append(parents)
	
	return candidates 
		
def Generate_initial_pop (pop_size, VF_size):
	initial_population = [] 
	for indx in range (pop_size):
		initial_population.append(list(np.random.rand(VF_size)) )

	return initial_population

def Main ():
	X,Y = general.Load_Data ("malware_dataset.csv")
	X = general.standarize (X)
	sigma = 0.246711580707

	pop_size = 20 ; FV_size = 95 ; maxiter = 10 ; 
	initial_pop = Generate_initial_pop (pop_size, FV_size)
	candidates= Genatic_Algo (X,Y,sigma,initial_pop,pop_size,maxiter)	
	import cPickle
	with open ("genetic_algo_pop","wb")as file:
		cPickle.dump (candidates,file)
Main()
