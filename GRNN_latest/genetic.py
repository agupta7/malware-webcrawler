import numpy as np 
import cPickle 
import random
import general
import GRNN
import operator 
import sys 

# my fitness function based on classification error  
def Fitness (out): # done 
	fitness = abs(out)
	return fitness	

# flat cross over 
def Flat_Cross_Over (parent1,parent2): # done 
	child = [] 
	for indx in range (len(parent1)):
		child.append (random.uniform(parent1[indx], parent2[indx]) )

	return child 
		
# Evaluate population 
def Evaluate_poputation (GRNN_inst, parents): # done 
        fitness_dict = dict()
        output = GRNN_inst.predict(parents) 

	for indx in range (len (parents)):
	        fitness_dict.update( {indx:Fitness(output[indx])} )  # list of tuples of all indices, fitness
	
        return fitness_dict

def Tournament_selection (parents, fitness): # done 
	chosen = random.sample ( range( len(parents)),2)# randomly choose 2 parents
	if fitness[ chosen[0] ] <=  fitness[ chosen[1] ]: # choose the best
		winner1 = parents[chosen[0]]
	else:	winner1 = parents[chosen[1]]

	while (chosen[0] == winner1 or chosen[1] == winner1): # make sure winner1 is not selected again 
		chosen = random.sample (range(len (parents)),2)# randomly choose 2 parents

	if fitness[ chosen[0] ] <=  fitness[ chosen[1] ]: # choose the best
		winner2 = parents[chosen[0]]
	else:	winner2 = parents[chosen[1]] 

	return [winner1, winner2]
	
def Create_child ( parents,fitness): # done 
#        print "create child\n"
	chosen_parents = Tournament_selection(parents, fitness)
        child = Flat_Cross_Over (chosen_parents[0], chosen_parents[1])#crossover

        return child

def replace_worst_parent(parents,child,fitness_p,fitness_c):# done 
	worst_k = -1 ; worst_v= -1  # search for worst parent	
	for key, value in fitness_p.iteritems():
		if value > worst_v:
			worst_v = value ; worst_k = key ; 

	print "\nreplace parent at indx %d with fitness: %f"%(worst_k,worst_v) 
 	parents [worst_k] = child ; 
	fitness_p[worst_k] = fitness_c [0]

	return parents, fitness_p

def Genatic_Algo (GRNN_inst, parents, poputation, maxiter): # done 
        fitness_p = Evaluate_poputation(GRNN_inst,parents) # evaluate first population
	for iter in range (0,maxiter):
		child = Create_child (parents, fitness_p) # create new generation 
       		fitness_c = Evaluate_poputation(GRNN_inst,[child]) # evaluate current child
		parents, fitness_p = replace_worst_parent (parents,child,fitness_p,fitness_c)# replace worst parent		
		
	return parents ,fitness_p 
		
def Generate_initial_pop (pop_size, VF_size): # done 
	initial_population = [] 
	for indx in range (pop_size):
		initial_population.append(list(np.random.rand(VF_size)) )

	return initial_population

def Select_random_Pop (X, pop_size):
	X = list(X)
	initial_population = []
	for i in range (pop_size):
		R = random.sample( range(len(X)) , 1)
		initial_population.append(list( X[R[0]]))

	return initial_population
def Main ():
	sigma = 0.246711580707
	pop_size = 20 ; FV_size = 95 ; maxiter = 200; 
	GRNN_inst=  GRNN.GRNNPredictor("malware_dataset.csv", sigma) 

	initial_pop = Generate_initial_pop (pop_size, FV_size)
#	initial_pop = Select_random_Pop (GRNN_inst.X,pop_size)
	candidates , fitness= Genatic_Algo (GRNN_inst,initial_pop,pop_size,maxiter)

	for key, value in fitness.iteritems():
		print key,": ",value
	print	
	
	
	import cPickle
	with open ("genetic_algo_pop","wb")as file:
		cPickle.dump (candidates,file)
Main()
