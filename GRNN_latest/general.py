import numpy as np  
import operator
import csv
import math
#################### load Data from csv file 
def Load_Data  (filename):
	X = []
	Y = []
	with open (filename, "rb") as file:
		reader = csv.reader (file)
		for line in reader:
			Y.append (float(line[1]))
			line.pop(0); line.pop(0) ;	
			X.append (np.array(line,dtype = np.double))

	print "Data loaded with shape: ",np.shape(X),
        pos = Y.count(1)	; neg = Y.count (-1)
        print " with pos: %d and neg: %d"%(pos,neg) # more is the class of majority instances

	X = np.array(X)
	Y = np.array(Y)

	return X , Y

def Modify_dataset (X,Y):
	#count positives and negatives ! 	
	keys, counts = np.unique (Y,return_counts = True)# keys = [-1,1], counts = [#-1's,#1's]
	neg = counts[0] ; pos = counts[1]
	Break = len(X) - min (neg,pos)*2 # find number of majority label instances 

	if neg > pos:	more = -1
	elif pos>neg:   more = 1 
	else :		return X,Y

	'''
	count = 0 
	indices = [] # insert indices from last to first to make it easier to delete from array
	for indx in range (len(Y)-1,0,-1):
		if Y[indx] == more and  all (X[indx] ==0 ):
			X.pop(indx);Y.pop(indx)
			count += 1 
	indices = [] # insert indices from last to first to make it easier to delet$
        for indx in range (len(Y)-1,0,-1):
                if Y[indx] == more:
                        X.pop(indx);Y.pop(indx)
			count += 1
		if count == Break:
			break 
	for indx in range (len(Y)-1,0,-1):
                if all ( X[indx] == 0):
                        X.pop(indx);Y.pop(indx)
	'''
        count = 0 ;
	print more , Break
        for i in range (Break):
		indx = list(Y).index(more)
	        X= np.delete(X,indx,0);Y = np.delete(Y,indx,0)
                count += 1
		if count == Break:
			break 

	keys, counts = np.unique (Y,return_counts = True)# keys = [-1,1], counts = [#-1's,#1's]
	neg = counts[0] ; pos = counts[1]
	print "data new shape: ", np.shape(X)," with pos: %d and neg: %d"%(pos,neg) # more is the class of majority instances
	
	return X , Y
##################### this function computes the accuracy of the model 
def Accuracy (output, doutput):
	Acc = 0 ; FP = 0 ; FN = 0 ; TP = 0 ; TN = 0 ; unkn = 0  
	for indx in range (len(output)):
		if output[indx] == 0:
			unkn += 1
		elif doutput[indx] == 1: 
			if output[indx] > 0:
				Acc += 1 
				TP += 1 
			elif output[indx] < 0:
				FN += 1 
		elif doutput[indx] == -1:
			if output[indx] < 0:
				Acc += 1
				TN += 1
			elif output[indx] > 0:
				FP += 1
#	print "UNKOWNS: ", unkn
	Acc = Acc*100.0/len(output)
#	print "Accuracy: %f FP: %d FN: %d TP: %d TN: %d"%(Acc,FP,FN,TP,TN)
	return Acc , FP, FN , TP , TN 

####################  this function returns the std for a single data instance 
def Std (instance):
	mean = sum(instance)/float(len(instance))
	dif_sqr = [math.pow(feature-mean,2) for feature in instance ]
	dif_mean =  sum(dif_sqr)/float(len(dif_sqr))	
	std = math.sqrt(dif_mean)
	return std 

##################### random shuffel for samples
def shuffle_in_unison_scary(a, b):
        rng_state = np.random.get_state()
        np.random.shuffle(a)
        np.random.set_state(rng_state)
        np.random.shuffle(b)
        print "Data is now shuffled"
        return a,b

#################### split data into training and testing, given the test data ratio
def split(ratio_tst, X, Y):
        Xtest, X = np.split(X, [ratio_tst*len(Y)] )
        Ytest, Y = np.split(Y, [ratio_tst*len(Y)] )
        print "splitted"
        return Xtest,X,Ytest,Y


def Variance_Feature_Select(X):
        sel = VarianceThreshold(threshold=(.85 * (1 - .85)))
        X = sel.fit_transform(X)
        print "featured Extracted: ",X.shape
        return X
		 	
def Normalization (X):
	print "Normalizing Data:\n"
	Mean = np.zeros(len(X[0]) ,dtype=float)
	Dev = np.zeros(len(X[0]) ,dtype=float)
	
	# normalizing on each feature
	for i in range (len(X[0])):
                Mean[i] = np.mean (X[:,i])
		Dev[i] =  Std(X[:,i])
	X = ( X - Mean)/Dev     # Normalizing the data
	print "MEAN: ", Mean 
	print "---------------------------------"
	print "DEV: ", Dev
	return X 

def standarize (X):
	X_ =  []
	for item in X:
                norm = np.square(item)
                norm = np.sqrt(np.sum (norm))
		if norm !=0:
                	X_.append (item/norm)#item = item/norm
		else:
			X_.append (item)

        return np.array(X_)	

def Normalization_min_max(X):
	x_min = np.zeros(len(X[0]) ,dtype=float)
        x_max= np.zeros(len(X[0]) ,dtype=float)
	
	for i in range( len(X[0])):
		x_min[i] = min (X[:,i])
		x_max[i] = max (X[:,i])

	X = (X - x_min)/(x_max - x_min)
	return X 
