import numpy as np
import random
import weighted_knn
import pickle

class WeightedKnnFeatureMaskEvolution:

    def __init__(self, evaluateFitness, lowerbound, upperbound):
        self.evaluateFitness = evaluateFitness
        self.lowerbound = lowerbound
        self.upperbound = upperbound
        self._generations = 200
        self._grabNParents = 10
        self._populationPool = 100

    def evolveFeatureMask(self):
        random.seed()
        #population = self.initializePopulation(self._populationPool)
        #pickle.dump(population, open('initialPop_50', 'wb'))
        population = pickle.load(open('initialPop_100', 'rb'))

        for i in range(0, self._generations):
            print 'generation {0}'.format(i + 1)
            parents = self.selectParents(population, self._grabNParents)
            children = self.procreate(parents[0]['mask'], parents[1]['mask'])

            for i in range(len(children)):
                child = children[i]
                children[i] = {'mask': child, 'accuracy': self.evaluateFitness(child)}
            population = self.calculateNextGeneration(population, children)

        return population[-1]['mask']


    def initializePopulation(self, popSize):
        population = list()
        for i in range(0, popSize):
            vector = [ ]
            for j in range(0, 95):
                r = random.random() * (self.upperbound - self.lowerbound) * 10000
                r = r % ((self.upperbound - self.lowerbound) * 100)
                r = r / 100 + self.lowerbound
                vector.append(r)
            accuracy = self.evaluateFitness(np.array(vector))
            population.append({'mask': np.array(vector), 'accuracy': accuracy})

        return population

    def selectParents(self, population, n):
        parents = []
        for i in range(n):
            randomIndex = random.randint(0, len(population) - 1)
            parents.append(population[randomIndex])
        return sorted(parents, key=lambda comparator: comparator['accuracy'])[-2:]

    def calculateNextGeneration(self, population, children):
        kill = len(children)
        population.extend(children)
        return sorted(population, key=lambda comparator: comparator['accuracy'])[(kill - 1):]

    def procreate(self, parentA, parentB):
        child = []
        for i in range(len(parentA)):
            up = max(parentA[i], parentB[i])
            lower = min(parentA[i], parentB[i])
            r = random.randint(int(lower * 100), int(up * 100)) / 100
            spread = up - lower
            r += 0.25 * random.randint(int(-spread * 100), int(spread * 100)) / 100 # mutation
            child.append(r)
        return [np.array(child)]
